<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>PIXI+Planck Demo</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/planck-js/0.2.7/planck.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.5/pixi.min.js"></script>
	<style>
		html, body {
			margin: 0;
			padding: 0;
			border: 0;
			width: 100%;
			height: 100%;
		}
	</style>
</head>
<body>
<script>
// Node integration thanks to Electron (otherwise you would source these in the head tag, like normal)
// PIXI
const renderer = new PIXI.Renderer({width: 1920, height: 1080, backgroundColor: 0x000000 });
document.body.appendChild(renderer.view);
const loader = PIXI.Loader.shared; 				// for v5+.  In v4 Loader should be lowercased?
// Layer our scene with containers
const stage = new PIXI.Container();				// Everything ends up here.
const spriteLayer = new PIXI.Container();		// Sprites in here.
	stage.addChild(spriteLayer);
const debugLayer = new PIXI.Container();		// Outlines/planck shapes.
	stage.addChild(debugLayer);
const uiLayer = new PIXI.Container();			// Text UI on top
	stage.addChild(uiLayer);
const boundaryGraphics = new PIXI.Graphics();	// our stage boundaries are on their own graphics object we handle
	debugLayer.addChild(boundaryGraphics);			// in the way planck.js provides us (this is a demo afterall)
var infoText = new PIXI.Text('', new PIXI.TextStyle({fill:'#ffffff'}));
	infoText.x = 30;
	infoText.y = 25;
	uiLayer.addChild(infoText);
var keyText = new PIXI.Text("", new PIXI.TextStyle({fill:'#ffffff'}));
	keyText.x = 20;
	keyText.y = renderer.screen.height - 40;
	uiLayer.addChild(keyText);
/*
	Planck

	Goes without saying, please read the Box2D Manual: https://box2d.org/manual.pdf

	We will be simulating Box2d on a small scale, as far as game resolutions are concerned.
	We then draw our game world over that at a much larger scale.

	I opted for two globals for clarity, PixelsPerMeter (b2d-to-PIXI) and MetersPerPixel (PIXI-to-b2d).
	You could just divide PixelsPerMeter when going into Box2d, but an operator is an easy oversight
	for an annoying bug, especially in a tutorial meant for new users.

	Further reading on the concept of scaling box2d: https://box2d.org/2011/12/pixels/
*/
var PixelsPerMeter = 50;					// How many pixels represent 1 meter.
var MetersPerPixel = 1/PixelsPerMeter;		// And the reverse.
var drawLines = false;						// Draw Debug lines?  Toggle this at runtime with the L key.
// Timing
var gameTime = 0;							// Elapsed time since updating began.
var lastTime = 0;
var frameTime = 0;
var accumulator = 0;
var timestep = 1000/30;						// run X fixed physics steps, per second.  Try turning this to 20 and interpolation to false.
var deltaTime = timestep/1000;				// Since we're fixed, we don't need to divide constantly during simulation.
var interpolation = true;					// Draw PIXI objects between physics states for smoother animation.
var forceStrength = 25;						// How much power our bunnies posses.
var deleteQueued = false;					// Destroying stuff during a physics step would be crashy.

// Our main Box2D world.
var world = planck.World({
	gravity: planck.Vec2(0,0)				// approximate normal earth gravity
});

var gameObjects = [];						// Our list of GameObject instances.

var ground = world.createBody({				// The confinement area for our sandbox
		userData: {
			myType: "boundary",
			label:"ground"
		}
	});
// fixme -- shortcuts for an old lazy programmer
const topLeft = planck.Vec2(20*MetersPerPixel,20*MetersPerPixel);
const topRight = planck.Vec2((renderer.screen.width-20)*MetersPerPixel,20*MetersPerPixel);
const bottomLeft = planck.Vec2(20*MetersPerPixel,(renderer.screen.height-40)*MetersPerPixel);
const bottomRight = planck.Vec2((renderer.screen.width-20)*MetersPerPixel,(renderer.screen.height-40)*MetersPerPixel);
// generate the fixtures on our ground body, one for each side of the room.
ground.createFixture(planck.Edge(topLeft,topRight));
ground.createFixture(planck.Edge(topRight,bottomRight));
ground.createFixture(planck.Edge(bottomRight,bottomLeft));
ground.createFixture(planck.Edge(bottomLeft,topLeft));

// The bread and butter.  This is (hopefully) a proper game loop, if I learned anything from the gaffer.
function step(t) {
	if(deleteQueued) {
		if(gameObjects.length) {
			gameObjects[0].destroy();
			gameObjects.splice(0,1);
		}
		deleteQueued = false; // dequeue if nothing is available
	}
	if(lastTime) {
		frameTime = t - lastTime;
		if(frameTime > 250) {					// Panic! In this state, we need to start removing objects!
			frameTime = 250;					// This is not very aggressive; you could do more in a 
			gameObjects[0].destroy();			// real world scenario.  Beyond my scope for now, though =D
			gameObjects.splice(0,1);
		}
		accumulator += frameTime;
		while(accumulator >= timestep) {
			for(let o = 0; o < gameObjects.length; o++) {
				if(!gameObjects[o].body.isStatic()) gameObjects[o].update(deltaTime);
			}
			world.step(deltaTime);				// step box2d
			gameTime += timestep;
			accumulator -= timestep;
		}
		render(accumulator / timestep);			// PIXI time.
	}
	lastTime = t;
	requestAnimationFrame(step);
}

function render(alpha) {
	for(let o = 0; o < gameObjects.length; o++) {
		gameObjects[o].integrate(alpha);
	}
	// Planck.js maintained box2d quite enthusiastically, including not-very-js ways of doing things.
	// Being a C++ library written in ~2007, it iterates strangely for javascript programmers =)
	// Also note, that most getters in planck.js are by reference, so that's fun!
	// I did the level boundaries in a more vanilla way here, so we could see an example of that in action.
	boundaryGraphics.clear();
	for (var body = world.getBodyList(); body; body = body.getNext()) {
		var userData = body.getUserData();
		if("gameObject" in userData) continue;	// we skip to the next object if this is a gameObject (handled these above already)
		for (var fixture = body.getFixtureList(); fixture; fixture = fixture.getNext()) {
			var shape = fixture.getShape();
			if(shape.getType() == 'edge' && userData.myType == 'boundary') {
				boundaryGraphics.lineStyle(3,0xFEEB77,1);
				boundaryGraphics.moveTo(shape.m_vertex1.x*PixelsPerMeter,shape.m_vertex1.y*PixelsPerMeter);
				boundaryGraphics.lineTo(shape.m_vertex2.x*PixelsPerMeter,shape.m_vertex2.y*PixelsPerMeter);
			}
		}	
	}
	boundaryGraphics.endFill();
	// Set our text for rendering. 
	infoText.text = "Steps: " + world.m_stepCount + " ("+ (world.m_stepCount / (gameTime/1000)).toFixed(2) + "/sec @ " + frameTime.toFixed(2) + "ms)";
	infoText.text += "\n#: " + gameObjects.length;
	keyText.text = 'SPACE: bunnies!    ENTER: random geometry    L: toggle debug lines    NumPad +/-: adjust gravity (' + world.getGravity().y.toFixed(2) + ")";
	keyText.text += "    , / . : impulse strength (" + forceStrength.toFixed(2) + ")    " + "DEL: remove object";
	// And finally...
	renderer.render(stage);
}
// When files are loaded and ready, we may begin.
loader.add('bunny','https://pixijs.io/examples/examples/assets/bunny.png')
	.load( (loader,resources) => {
		requestAnimationFrame(step);
	});
// Input
document.addEventListener('keyup', (ev) => {
	
});
document.addEventListener('keydown',(ev) => {
	if(ev.code == "Delete") {
		deleteQueued = true;
	}
	if(ev.code == "Comma") {
		forceStrength -= 40 * deltaTime;
		if(forceStrength < 0) forceStrength = 0;
	}
	if(ev.code == "Period") {
		forceStrength += 40 * deltaTime;
		if(forceStrength > 100) forceStrength = 100;
	}
	if(ev.code == "KeyL") {
		drawLines = drawLines ? false : true;
	}
	if(ev.code == "NumpadAdd") {
		var g = world.getGravity().clone();
			g.y += 0.5;
		if(g.y > 99) g.y = 99;
		world.setGravity(g);
	}
	if(ev.code == "NumpadSubtract") {
		var g = world.getGravity().clone();
			g.y -= 0.5;
		if(g.y < -99) g.y = -99;
		world.setGravity(g);
	}
	if(ev.code == 'Space') {
		var r = randrange(10,25)
		var o = new GameObject({
			world: world,
			position: {x:200,y:200},
			angle: Math.random(),
			angularVelocity: randrange(1,5),
			radius: r,
			type: 'dynamic',
			shape: 'circle',
			color: randcolor(),
			restitution: randrange(1,50) / 100,
			friction: randrange(1,50) / 100,
			density: randrange(r,r*2),
			texture: 'bunny.png' 
		});
		o.body.applyLinearImpulse({x:randrange(forceStrength,forceStrength*2),y:randrange(forceStrength,forceStrength*2)},o.body.getWorldCenter());
	}
	if(ev.code == 'Enter') {
		var o = new GameObject({
			world: world,
			position: {x:200,y:200},
			angle: Math.random(),
			angularVelocity: randrange(1,5),
			radius: randrange(25,50),
			type: 'dynamic',
			shape: randrange(1,100) > 50 ? 'box' : 'circle',
			color: randcolor(),
			restitution: randrange(1,100) / 100,
			friction: randrange(1,100) / 100,
			density: randrange(1,20),
			texture: null
		});
		o.body.applyLinearImpulse({x:randrange(forceStrength,forceStrength*2),y:randrange(forceStrength,forceStrength*2)},o.body.getWorldCenter());
	}
});
/*
	Box2d is a verbose library.  In addition, it has definitions each for Body, Fixture, and Shape; which can be overwhelming.
	This is a basic class that blends some of the common ones and saves a bit of typing.
*/
class GameObject {
	constructor(opts) {
		// If no texture is supplied we become a solid shape.
		this.sprite = typeof opts.texture == 'string' ? new PIXI.Sprite.from(opts.texture) : new PIXI.Graphics();		
		this.debug = new PIXI.Graphics();			
		this.container = new PIXI.Container();
		this.shapeType = opts.shape;
		this.world = opts.world;
		this.body = this.world.createBody({
			type: opts.type,
			angularVelocity: opts.angularVelocity,
			position: { x: opts.position.x * MetersPerPixel, y: opts.position.y * MetersPerPixel },
			userData: {	// We assign some userData for this body for future handling
				gameObject:true
			}
		});
		if(this.shapeType == 'box') {
			this.body.createFixture(planck.Box((opts.radius/2)*MetersPerPixel,(opts.radius/2)*MetersPerPixel),{
				friction: opts.friction,
				restitution: opts.restitution,
				density: opts.density
			});
			if(this.sprite instanceof PIXI.Sprite == false) {
				this.sprite.beginFill(opts.color,1); 
				this.sprite.drawRect(0,0, opts.radius, opts.radius);
				this.sprite.endFill();
				// Boxes need their origin centralized, because box2d uses center of mass (this keeps our "sprite" within our body.  
				// Circles do this naturally
				this.sprite.pivot.x = this.sprite.width / 2;
				this.sprite.pivot.y = this.sprite.height / 2;
			}
		}
		else if(this.shapeType == 'circle') {
			this.body.createFixture(planck.Circle(opts.radius*MetersPerPixel), {
				friction: opts.friction,
				restitution: opts.restitution,
				density: opts.density
			});
			if(this.sprite instanceof PIXI.Sprite == false) {
				this.sprite.beginFill(opts.color,1);
				this.sprite.drawCircle(0,0,opts.radius);
				this.sprite.endFill();
			}
		} else throw("Unsupported physics shape!");
		// For interpolation, we need to know our Body's previous physics state.
		this.previousState = new PhysicsState();
		this.previousState.assign(this.body.getPosition(),this.body.getAngle());
		// If a texture is present, we need to center our origin
		if(this.sprite instanceof PIXI.Sprite) {
			this.sprite.pivot.x = this.sprite.width / 2;
			this.sprite.pivot.y = this.sprite.height / 2;
			this.sprite.scale.set(opts.radius*MetersPerPixel*(PixelsPerMeter/12),opts.radius*MetersPerPixel*(PixelsPerMeter/12));
		}
		// Container is our main interface to PIXI.
		this.container.pivot.x = this.container.width / 2;
		this.container.pivot.y = this.container.height / 2;
		this.container.x = opts.position.x * PixelsPerMeter;
		this.container.y = opts.position.y * PixelsPerMeter;
		this.container.addChild(this.sprite);	// Add the sprite after you setup the container, lest it gets goofy.
		spriteLayer.addChild(this.container);
		// Debug lines
		this.debug.x = this.container.x = opts.position.x;
		this.debug.y = this.container.y = opts.position.y;
		debugLayer.addChild(this.debug);			
		// Finally, we add ourselves to the list of game objects for future iteration.
		gameObjects.push(this);
	}
	integrate(alpha) {
		// Interpolate or snap?
		this.container.x = interpolation ? (this.body.getPosition().x * alpha) * PixelsPerMeter + (this.previousState.position.x * (1-alpha)) * PixelsPerMeter : this.body.getPosition().x * PixelsPerMeter;
		this.container.y = interpolation ? (this.body.getPosition().y * alpha) * PixelsPerMeter + (this.previousState.position.y * (1-alpha)) * PixelsPerMeter : this.body.getPosition().y * PixelsPerMeter;
		this.container.rotation = interpolation ? this.body.getAngle() * alpha + this.previousState.angle * (1-alpha) : this.body.getAngle();	// we don't convert rotations
		// Debug lines -- Yeah, these are not very fast, but useful for a testbed.
		this.debug.clear();
		if(drawLines) {
			this.debug.x = this.container.x;
			this.debug.y = this.container.y;
			this.debug.rotation = interpolation ? this.body.getAngle() * alpha + this.previousState.angle * (1-alpha) : this.body.getAngle();
			this.debug.lineStyle(1,0x00ff2a,1);
			if(this.shapeType == 'box') { // width and height don't seem to be a concept to boxes in box2d, so we go by their vertices.
				for(var fixture = this.body.getFixtureList(); fixture; fixture = fixture.getNext()) {
					var shape = fixture.getShape(); // we do make an assumption that there's just one fixture; keep this in mind if you add more.
					this.debug.moveTo(shape.getVertex(0).x * PixelsPerMeter, shape.getVertex(0).y * PixelsPerMeter);
					for(var v = 1; v < shape.m_count; v++) {
						this.debug.lineTo(shape.getVertex(v).x * PixelsPerMeter, shape.getVertex(v).y * PixelsPerMeter);
					}
					this.debug.lineTo(shape.getVertex(0).x * PixelsPerMeter, shape.getVertex(0).y * PixelsPerMeter);
				}
			}
			else if(this.shapeType == 'circle') {
				var r = this.body.getFixtureList().getShape().m_radius;
				this.debug.drawCircle(0,0,r * PixelsPerMeter);
			}
			this.debug.endFill();
		}
	}
	update() {
		this.previousState.assign(this.body.getPosition(),this.body.getAngle());
	}
	destroy() { // Goodbye, sweet world
		// box2d cleanup
		this.world.destroyBody(this.body);
		// pixi cleanup
		this.container.destroy({children: true});
		this.debug.destroy();
	}
}
class PhysicsState {
	constructor() {
		this.position = planck.Vec2(0,0);
		this.angle = 0;
	}
	assign(position,a) {
		this.position = planck.Vec2.clone(position);	// avoid the reference boogie-man
		this.angle = a;
	}
}
// Some helpers, just for fun.
function randrange(min,max) { return Math.floor(Math.random() * (Math.floor(max) - Math.ceil(min) + 1)) + Math.ceil(min); }
function randcolor() { return '0x'+Math.floor(Math.random()*16777215).toString(16) }
</script>
</body>
</html>